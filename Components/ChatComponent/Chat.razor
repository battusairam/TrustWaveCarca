@page "/chat/{userId}/{TargetUserId}"
@using Microsoft.AspNetCore.SignalR
@using Microsoft.AspNetCore.SignalR.Client
@using TrustWaveCarca.Components.ChatComponent
@using TrustWaveCarca.Components.ChatComponent.Feature
@using TrustWaveCarca.Data
@using TrustWaveCarca.Services
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject IHubContext<ChatHub> HubContext
@inject ChatMessageService chatservice
@rendermode InteractiveServer
 
@attribute [Authorize]

<style>

    .chat-container {
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
        background-color: #f1f1f1;
        border-radius: 8px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .chat-header {
        padding: 10px;
        background: linear-gradient(120deg, #6a11cb, #2575fc);
        color: white;
        border-radius: 8px 8px 0 0;
        text-align: center;
        font-size: 1.2rem;
    }

    .user-status {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        margin-top: 10px;
    }

        .user-status span {
            font-size: 1rem;
            margin-right: 5px;
        }

    .chat-messages {
        flex-grow: 1;
        padding: 10px;
        background-color: white;
        margin: 10px 0;
        overflow-y: auto;
        max-height: 300px;
        border: 1px solid #ccc;
        border-radius: 5px;
    }

        /* Hide the scrollbar for Webkit browsers (Chrome, Safari, Edge) */
        .chat-messages::-webkit-scrollbar {
            display: none; /* Hides the scrollbar */
        }

    /* Hide the scrollbar for Firefox */
    .chat-messages {
        scrollbar-width: none; /* For Firefox */
    }

        /* Optionally, if you want to remove the 'track' and 'thumb' in other browsers */
        .chat-messages::-webkit-scrollbar-track {
            background: transparent; /* Hide the track */
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: transparent; /* Hide the thumb */
        }

        .chat-messages ul {
            list-style-type: none;
            padding: 0;
        }

        .chat-messages li {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 15px;
            
            position: relative;
            max-width: 50%;
            word-wrap: break-word;
        }

    .sent {
        background-color: #e7e7e7;
        color: black;
        align-self: flex-end; /* Right side for sent messages */
        margin-left: auto; /* Right side */
    }

    .received {
        background-color: #e7e7e7;
        color: black;
        align-self: flex-start; /* Left side for received messages */
        margin-right: auto; /* Left side */
      
    }


    .chat-input {
        display: flex;
        gap: 10px;
        margin-top: 10px;
    }

        .chat-input input {
            flex-grow: 1;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        .chat-input button {
            padding: 8px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

            .chat-input button:hover {
                background-color: #0056b3;
            }

    .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
        margin-left: 5px;
    }

    .online {
        background-color: green;
    }

    .offline {
        background-color: red;
    }

    /* Apply color only to the word 'Send' */
    .sent-text {
        color: #007bff; /* Blue color for "Send" */
    }

    .received-text {
        color: #2e7d32; /* Green color for "Send" */
    }

    .message-time {
        font-size: 0.8rem;
        color: #888;
        margin-left: 10px;
    }

    .typing-indicator {
        font-style: italic;
        color: #888;
        margin-top: 5px;
        margin-bottom: -10px;
    }
    .messages-container {
    height: 300px; /* Set a fixed height */
    overflow-y: scroll; /* Enable vertical scrolling */
    scroll-behavior: smooth; /* Smooth scroll effect */
}

</style>

<div class="chat-container">
    <div class="chat-header">
        <h3>Chat with User @TargetUserId</h3>
    </div>
    <div class="user-status">
        <span>Status:</span>
        <span class="status-dot @GetUserStatusClass(TargetUserId)"></span>
    </div>
    <div>
      @*   @if (isTyping)
        {
            <p class="typing-indicator"> is typing...</p>
        } *@
         @if (isTyping && TargetUserId != UserId) 
         {
            <p class="typing-indicator">@TargetUserId is typing...</p>
         }
    </div>
    <div class="chat-messages" @ref="messagesContainer">
        @if (messages.Any())
        {
            <ul>
        @foreach (var msg in messages)
        {
            <li class="@GetMessageClass(msg)">
                <span class="message-content">
                    @if (msg.SenderId == UserId) 
                    {
                        <span class="sent-text">Send: </span>  <!-- Display "Send" for sent messages -->
                        @msg.Content
                    }
                    else   
                    {
                        <span class="received-text">Received: </span>  <!-- Display "Received" for received messages -->
                        @msg.Content
                    }
                </span>
                <span class="message-time">
                    @msg.Timestamp.ToString("hh:mm tt")
                </span>
            </li>
        }
            </ul>
        }
        else
        {
            <p>No messages yet.</p>
        }
    </div>

    <div class="chat-input">
        <button class="btn" @onclick="ToggleEmojiPicker">😊</button>
        <input type="text" @bind="message" @oninput="OnMessageTyping" placeholder="Type a message..." />
        <button class="btn btnbgcolor"
                @onclick="SendMessage"
                disabled="@(hubConnection?.State != HubConnectionState.Connected)">
            <i class="bi bi-send-fill"></i> Send
        </button>
    </div>

    <!-- Emoji picker component -->
    <EmojiPicker OnEmojiSelected="OnEmojiSelected" />

</div>

@code 
{
    [Parameter] public string UserId { get; set; }
    [Parameter] public string TargetUserId { get; set; }


    private HubConnection? hubConnection;
    private string message = string.Empty;
    private List<ChatMessage> messages = new List<ChatMessage>();
    private ElementReference messagesContainer;
    private Dictionary<string, bool> userStatuses = new();
    private bool isTyping;
    private Timer typingTimer;

    private string GetUserStatusClass(string userId)
    {
        return userStatuses.ContainsKey(userId) && userStatuses[userId] ? "online" : "offline";
    }

    private async void OnMessageTyping()
    {
        if (!isTyping)
        {
            isTyping = true;
            await NotifyTyping(true);
        }

        typingTimer?.Dispose();
        typingTimer = new Timer(TypingTimeout, null, 2000, Timeout.Infinite);
    }

    private async void TypingTimeout(object state)
    {
        isTyping = false;
       await NotifyTyping(false);

        await InvokeAsync(StateHasChanged);
    }

    private async Task NotifyTyping(bool typing)
    {
        if (hubConnection != null)
        {
            await hubConnection.SendAsync("NotifyTyping", UserId, TargetUserId, typing);
        }
    }


    private string GetMessageClass(ChatMessage msg)
    {
        // Check if the message was sent by the current user
        if (msg.SenderId == UserId)
        {
            return "sent";  // Sent message will appear on the right
        }
        else
        {
            return "received";  // Received message will appear on the left
        }
    }


    private void ToggleEmojiPicker()
    {
        JSRuntime.InvokeVoidAsync("toggleEmojiPicker");
    }

    // Handle emoji selection
    private void OnEmojiSelected(string emoji)
    {
        message += emoji; // Add the selected emoji to the message input field
    }


    protected override async Task OnInitializedAsync()
    {
        // Establish SignalR connection
        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri($"/chathub?userId={UserId}"))
            .WithAutomaticReconnect()
            .Build();

        // Fetch the existing chat history
        messages = await chatservice.GetMessages(UserId, TargetUserId);

        var uniqueMessages = messages.DistinctBy(msg => msg.MessageId).ToList();
        messages = uniqueMessages;
        hubConnection.On<string, bool>("UserTyping", async (fromUserId, isTyping) =>
        {
            if (fromUserId == TargetUserId)
            {
                this.isTyping = isTyping;
                await InvokeAsync(StateHasChanged);
            }
        });

        hubConnection.On<string, bool>("UpdateUserStatus", async (userId, isOnline) =>
        {
            if (!string.IsNullOrEmpty(userId))
            {
                userStatuses[userId] = isOnline;
                await InvokeAsync(StateHasChanged);
            }
        });

        hubConnection.On<string, string>("ReceiveMessage", (receivedMessage, messageId) =>
        {
            // Check if the message has already been received based on the unique ID
            if (!messages.Any(msg => msg.MessageId == messageId))
            {
                InvokeAsync(async () =>
                {
                    // Store received message in the database
                    var receivedChatMessage = new ChatMessage
                        {
                            SenderId = TargetUserId,
                            ReceiverId = UserId,
                            Content = receivedMessage,
                            Timestamp = DateTime.UtcNow.AddHours(5).AddMinutes(30),
                            IsRead = false,
                            MessageId = messageId // Store the unique message ID
                        };
                    await chatservice.SaveMessageToDatabase(receivedChatMessage);

                    // Add to local message list
                    messages.Add(receivedChatMessage);
                    await ScrollToBottom();
                    await InvokeAsync(StateHasChanged);

                });
            }
        });

        try
        {
            // Start the connection and ensure the status is updated
            await hubConnection.StartAsync();
            await NotifyUserStatus(true);
            Console.WriteLine("Connection started successfully.");
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error starting connection: {ex.Message}");
        }
    }


    private async Task NotifyUserStatus(bool isOnline)
    {
        if (hubConnection != null)
        {
            await hubConnection.SendAsync("NotifyUserStatus", UserId, isOnline);
        }
    }

    private async Task SendMessage()
    {
        if (hubConnection is not null && hubConnection.State == HubConnectionState.Connected && !string.IsNullOrEmpty(message))
        {
            try
            {
                // Create a unique identifier for the message to prevent duplicate sends
                var messageId = Guid.NewGuid().ToString();
                // Send the message via SignalR
                await hubConnection.SendAsync("SendMessage", TargetUserId, message,messageId);

                // Store the sent message in the database
                var sentMessage = new ChatMessage
                    {
                        SenderId = UserId,
                        ReceiverId = TargetUserId,
                        Content = message,
                        Timestamp = DateTime.UtcNow.AddHours(5).AddMinutes(30),
                        IsRead = false, // Message is initially unread
                        MessageId = messageId // Store the unique message ID
                    };
                await chatservice.SaveMessageToDatabase(sentMessage);

                // Add to local message list for immediate display
                messages.Add(sentMessage);
               
                // Immediately trigger UI update
                await InvokeAsync(StateHasChanged);  // Ensure the UI is updated

                // Scroll to the bottom after sending a new message
                await ScrollToBottom();

                // Clear the input message
                message = string.Empty;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error sending message: {ex.Message}");
            }
        }
        else
        {
            Console.Error.WriteLine("Cannot send message: The connection is not active.");
        }
    }

   
    private async Task ScrollToBottom()
    {
        // This uses JS interop to scroll the chat messages container to the bottom
        await JSRuntime.InvokeVoidAsync("scrollToBottom", messagesContainer);
    }

    public void Dispose()
    {
        if (hubConnection is not null)
        {
            _ = hubConnection.DisposeAsync();
        }
    }

    
    // public class ChatMessage
    // {
    //     public string Content { get; set; }
    //     public DateTime Timestamp { get; set; }
    // }
}
